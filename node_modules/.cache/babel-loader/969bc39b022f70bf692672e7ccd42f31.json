{"remainingRequest":"/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/babel-loader/lib/index.js!/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/eslint-loader/index.js??ref--13-0!/Users/jessehen/PhpstormProjects/lifecoach-frontend/src/util.js","dependencies":[{"path":"/Users/jessehen/PhpstormProjects/lifecoach-frontend/src/util.js","mtime":1577651494360},{"path":"/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _typeof from \"/Users/jessehen/PhpstormProjects/lifecoach-frontend/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\nexport function find(list, f) {\n  return list.filter(f)[0];\n}\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\nexport function deepCopy(obj) {\n  var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  // just return if obj is immutable value\n  if (obj === null || _typeof(obj) !== 'object') {\n    return obj;\n  } // if obj is hit, it is in circular structure\n\n\n  var hit = find(cache, function (c) {\n    return c.original === obj;\n  });\n\n  if (hit) {\n    return hit.copy;\n  }\n\n  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n\n  cache.push({\n    original: obj,\n    copy: copy\n  });\n  Object.keys(obj).forEach(function (key) {\n    copy[key] = deepCopy(obj[key], cache);\n  });\n  return copy;\n}\n/**\n * forEach for object\n */\n\nexport function forEachValue(obj, fn) {\n  Object.keys(obj).forEach(function (key) {\n    return fn(obj[key], key);\n  });\n}\nexport function isObject(obj) {\n  return obj !== null && _typeof(obj) === 'object';\n}\nexport function isPromise(val) {\n  return val && typeof val.then === 'function';\n}\nexport function assert(condition, msg) {\n  if (!condition) throw new Error(\"[vuex] \".concat(msg));\n}\nexport function partial(fn, arg) {\n  return function () {\n    return fn(arg);\n  };\n}",{"version":3,"sources":["/Users/jessehen/PhpstormProjects/lifecoach-frontend/src/util.js"],"names":["find","list","f","filter","deepCopy","obj","cache","hit","c","original","copy","Array","isArray","push","Object","keys","forEach","key","forEachValue","fn","isObject","isPromise","val","then","assert","condition","msg","Error","partial","arg"],"mappings":";;;;AAAA;;;;;;;;AAQA,OAAO,SAASA,IAAT,CAAeC,IAAf,EAAqBC,CAArB,EAAwB;AAC3B,SAAOD,IAAI,CAACE,MAAL,CAAYD,CAAZ,EAAe,CAAf,CAAP;AACH;AAED;;;;;;;;;;AASA,OAAO,SAASE,QAAT,CAAmBC,GAAnB,EAAoC;AAAA,MAAZC,KAAY,uEAAJ,EAAI;;AACvC;AACA,MAAID,GAAG,KAAK,IAAR,IAAgB,QAAOA,GAAP,MAAe,QAAnC,EAA6C;AACzC,WAAOA,GAAP;AACH,GAJsC,CAMvC;;;AACA,MAAME,GAAG,GAAGP,IAAI,CAACM,KAAD,EAAQ,UAAAE,CAAC;AAAA,WAAIA,CAAC,CAACC,QAAF,KAAeJ,GAAnB;AAAA,GAAT,CAAhB;;AACA,MAAIE,GAAJ,EAAS;AACL,WAAOA,GAAG,CAACG,IAAX;AACH;;AAED,MAAMA,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcP,GAAd,IAAqB,EAArB,GAA0B,EAAvC,CAZuC,CAavC;AACA;;AACAC,EAAAA,KAAK,CAACO,IAAN,CAAW;AACPJ,IAAAA,QAAQ,EAAEJ,GADH;AAEPK,IAAAA,IAAI,EAAJA;AAFO,GAAX;AAKAI,EAAAA,MAAM,CAACC,IAAP,CAAYV,GAAZ,EAAiBW,OAAjB,CAAyB,UAAAC,GAAG,EAAI;AAC5BP,IAAAA,IAAI,CAACO,GAAD,CAAJ,GAAYb,QAAQ,CAACC,GAAG,CAACY,GAAD,CAAJ,EAAWX,KAAX,CAApB;AACH,GAFD;AAIA,SAAOI,IAAP;AACH;AAED;;;;AAGA,OAAO,SAASQ,YAAT,CAAuBb,GAAvB,EAA4Bc,EAA5B,EAAgC;AACnCL,EAAAA,MAAM,CAACC,IAAP,CAAYV,GAAZ,EAAiBW,OAAjB,CAAyB,UAAAC,GAAG;AAAA,WAAIE,EAAE,CAACd,GAAG,CAACY,GAAD,CAAJ,EAAWA,GAAX,CAAN;AAAA,GAA5B;AACH;AAED,OAAO,SAASG,QAAT,CAAmBf,GAAnB,EAAwB;AAC3B,SAAOA,GAAG,KAAK,IAAR,IAAgB,QAAOA,GAAP,MAAe,QAAtC;AACH;AAED,OAAO,SAASgB,SAAT,CAAoBC,GAApB,EAAyB;AAC5B,SAAOA,GAAG,IAAI,OAAOA,GAAG,CAACC,IAAX,KAAoB,UAAlC;AACH;AAED,OAAO,SAASC,MAAT,CAAiBC,SAAjB,EAA4BC,GAA5B,EAAiC;AACpC,MAAI,CAACD,SAAL,EAAgB,MAAM,IAAIE,KAAJ,kBAAoBD,GAApB,EAAN;AACnB;AAED,OAAO,SAASE,OAAT,CAAkBT,EAAlB,EAAsBU,GAAtB,EAA2B;AAC9B,SAAO,YAAY;AACf,WAAOV,EAAE,CAACU,GAAD,CAAT;AACH,GAFD;AAGH","sourcesContent":["/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\nexport function find (list, f) {\n    return list.filter(f)[0]\n}\n\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\nexport function deepCopy (obj, cache = []) {\n    // just return if obj is immutable value\n    if (obj === null || typeof obj !== 'object') {\n        return obj\n    }\n\n    // if obj is hit, it is in circular structure\n    const hit = find(cache, c => c.original === obj)\n    if (hit) {\n        return hit.copy\n    }\n\n    const copy = Array.isArray(obj) ? [] : {}\n    // put the copy into cache at first\n    // because we want to refer it in recursive deepCopy\n    cache.push({\n        original: obj,\n        copy\n    })\n\n    Object.keys(obj).forEach(key => {\n        copy[key] = deepCopy(obj[key], cache)\n    })\n\n    return copy\n}\n\n/**\n * forEach for object\n */\nexport function forEachValue (obj, fn) {\n    Object.keys(obj).forEach(key => fn(obj[key], key))\n}\n\nexport function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n}\n\nexport function isPromise (val) {\n    return val && typeof val.then === 'function'\n}\n\nexport function assert (condition, msg) {\n    if (!condition) throw new Error(`[vuex] ${msg}`)\n}\n\nexport function partial (fn, arg) {\n    return function () {\n        return fn(arg)\n    }\n}\n"]}]}